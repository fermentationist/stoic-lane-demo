# stoic-lane-demo
---

A URL shortener made by [Dennis Hodges](https://dennis-hodges.com).

## Use

1. **`cd` into project root.**
2. **Type `npm install`.**
3. **To build and run app, type `npm start`.** (Or, to run dev server, type `npm run dev`.)
4. **After build is complete, open [localhost:4000](http://localhost:4000) in your browser.** (Or, if running dev server, go to [localhost:3000](http://localhost:3000) instead.)

### Tests

* **To run API tests, type `npm test`.**

## Description
* **Data Storage**: 
**Implementation**: For the sake of simplicity and portability (I didn't want the user to have to configure a local env among other things), a SQLite database was used. A simple table, named redirects, was used:
`
CREATE TABLE IF NOT EXISTS redirects(
    id BIGINT PRIMARY KEY NOT NULL,
    url VARCHAR(2048) NOT NULL UNIQUE
  );
`
**Scaling**: While a SQLite database is not a very scalable storage solution, a more robust SQL database would probably still be an appropriate choice to store redirects. (There are also solutions like Vitess and services like Planetscale that can horizontally scale a MySQL database.) A relational table fits the data as well or better than a document-based storage solution, in my opinion.
* **URL Generation**:
**Implementation**: Short (8 or 9 chars), unique alphanumeric ids are generated by converting the current Unix timestamp in milliseconds to a base36 string. They are appended to the host URL to create the shortened link. These ids will be unique as long as they are created at least 1ms apart (a rate limiter is in place to guarantee this). The integer-based timestamp value used to construct the id is used as a primary key in the database, instead of the base36 version, for faster indexing.
**Scaling**: I chose this solution for ease of implementation, but its limitations mean that a different solution will be needed at scale. For instance, the uniqueness of the ids is dependent on generating no more than one in any given millisecond. Currently, a rate limiter is being used to prevent this, but guaranteeing uniqueness will be even more difficult with multiple servers. 
Some other possible solutions: A true UUID can be used, but it will result in a significantly longer URL, which we probably don't want. Another solution might be to create a database table full of pre-generated random ids, already tested for uniqueness (allowing them to be fairly short - for example, there are 62^6, or over 56 billion possible 6-character alphanumeric combinations, if using upper and lower case letters). This number can be further expanded by using multiple domains and/or subdomains.
* **Server**: 
**Implementation**: I have used a Node.js (Express) server, because it is well-suited to the task, but *mostly* because of my preexisting familiarity with it, making it a fast and easy option. The API consists of three endpoints: `POST /api/shorten-url`, `GET /api/test` and `GET /:redirectID`. The first does the work of returning a shortened URL, the second is just for testing, and then the redirect path for shortened URLs.
**Scaling**: Node.js is asynchronous and capable of handling up to ~15K requests/second, making it a decent choice as the project scales. Of course, a load balancer would be needed once multiple servers become necessary.
* **User Interface**:
**Implementation**: The front end is built with React, again largely because I have a lot of familiarity with it, making it fast and easy to develop with. The app works as I intended and is fairly fast, but there are probably other, more lightweight front end solutions that could have been used (maybe Svelte or vanilla JS), especially given the simplicity of the app.
**Scaling**: The choice of client is not a concern of scale to the same degree that decisions around the back end are. This SPA should work fine at scale, though it should perhaps first be optimized for performance and undergo some design refinement.